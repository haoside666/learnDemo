## 正则表达式

正则表达式学习入门平台: https://www.codejiaonang.com

正则表达式教程:http://rexegg.com/

正则表达式练习网站:https://regexr-cn.com/   		or 	   https://regex101.com/



## 入门

### 1.字符组

字符组（`[]`）允许匹配一组可能出现的字符。

![image-20230227132001149](.\images\image-20230227132001149.png)

### 2.区间

1. 要匹配任意数字可以使用`[0-9]`；

2. 如果想要匹配所有小写字母，可以写成`[a-z]`；

3. 想要匹配所有大写字母可以写成`[A-Z]`

   下面例子只匹配一位

![image-20230227132429046](.\images\image-20230227132429046.png)

匹配特殊字符(通过\转义以及|连接多种不同的情况)

![image-20230227132705914](.\images\image-20230227132705914.png)

### 3.取反

​	可以通过在字符数组开头使用 `^` 字符实现取反操作，从而可以反转一个字符组（意味着会匹配任何指定字符之外的所有字符）。

![image-20230227133437649](.\images\image-20230227133437649.png)

### 4.快捷匹配数字和字母

![image-20230227133610553](.\images\image-20230227133610553.png)



`\s`快捷方式可以**匹配空白字符**，比如空格，tab、换行等。

`\b` 匹配的是单词的边界，例如，

![image9](.\images\1.png)

​	 `\bmaster\b` 就仅匹配有边界的`master`单词。

#### **快捷方式取反**

对于`\w`的取反为`\W`，将小写改写成大写即可，其他快捷方式也遵循这个规则,如\D \S等。

![image-20230227134618706](.\images\image-20230227134618706.png)

### 5.开始与结束

正则表达式中 `^`指定的是一个字符串的开始，`$`指定的是一个字符串的结束

注意与区间中的^区别

![image-20230227134843478](.\images\image-20230227134843478.png)

### 6.任意字符

`.`字符代表匹配任何单个字符，它**只能出现在方括号以外**

**值得注意的是：** `.`字符只有一个不能匹配的字符，也就是换行符（`\n`）

![image-20230227135043478](.\images\image-20230227135043478.png)

### 7.可选字符

​	这个时候我们可以使用 `?` 符号指定一个字符、字符组或其他基本单元可选，这意味着正则表达式引擎将会期望该字符出现**零次或一次**。

![image-20230227135256559](.\images\image-20230227135256559.png)

.?表示任意字符可出现0次或者1次

![image-20230227140700813](.\images\image-20230227140700813.png)

### 8.重复

在一个字符组后加上`{N}` 就可以表示在它之前的字符组出现`N`次。

![image16](.\images\2.png)

![image-20230227141237554](.\images\image-20230227141237554.png)

#### 重复区间

\d{3,4}` 既可以匹配`3`个数字也可以匹配`4个数字,不过当有`4`个数字的时候，优先匹配的是`4`个数字，这是因为正则表达式默认是**贪婪模式**，即尽可能的匹配更多字符，而要使用**非贪婪模式**，我们要在**表达式后面加上 `?`号**。

![image-20230227141422771](.\images\image-20230227141422771.png)

#### 开闭区间

\d{1,}表示匹配一个及一个以上的任意数字

可以使用 `+` 匹配`1`个到无数个，使用 `*`代表`0`个到无数个。

即：`+`等价于`{1,}`，`*`等价于`{0,}`。

![image-20230227141943899](.\images\image-20230227141943899.png)

#### 匹配所有手机号码

![image-20230227142053363](.\images\image-20230227142053363.png)

![image-20230227144210526](.\images\image-20230227144210526.png)

#### 匹配网站地址

![image-20230227142216755](.\images\image-20230227142216755.png)

![image-20230227145124270](.\images\image-20230227145124270.png)

### 入门总结

第一个阶段我们学到的所有内容可以总结如下：

#### 多种匹配模式

| 实例          | 描述                                |
| ------------- | ----------------------------------- |
| `[Pp]ython`   | 匹配 “Python” 或 “python”。         |
| `rub[ye]`     | 匹配 “ruby” 或 “rube”。             |
| `[abcdef]`    | 匹配中括号内的任意一个字母。        |
| `[0-9]`       | 匹配任何数字。类似于 [0123456789]。 |
| `[a-z]`       | 匹配任何小写字母。                  |
| `[A-Z]`       | 匹配任何大写字母。                  |
| `[a-zA-Z0-9]` | 匹配任何字母及数字。                |
| `[^au]`       | 除了au字母以外的所有字符。          |
| `[^0-9]`      | 匹配除了数字外的字符。              |

| 实例 |                             描述                             |
| ---- | :----------------------------------------------------------: |
| `.`  | 匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。 |
| `?`  |        匹配一个字符零次或一次，另一个作用是非贪婪模式        |
| `+`  |                        匹配1次或多次                         |
| `*`  |                        匹配0次或多次                         |
| `\b` |                   匹配一个长度为`0`的子串                    |
| `\d` |               匹配一个数字字符。等价于 [0-9]。               |
| `\D` |            匹配一个非数字字符。等价于 [ ^0-9 ]。             |
| `\s` | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 |
| `\S` |         匹配任何非空白字符。等价于 [ ^ \f\n\r\t\v]。         |
| `\w` |      匹配包括下划线的任何单词字符。等价于[A-Za-z0-9_]。      |
| `\W` |         匹配任何非单词字符。等价于[ ^ A-Za-z0-9_ ]。         |

## 进阶

### 分组

​	在正则表达式中还提供了一种将表达式**分组**的机制，当使用分组时，除了获得整个匹配。还能够在匹配中选择每一个分组。

​	要实现分组很简单，使用`()`即可

![image](.\images\3.png)

![image-20230227150712327](.\images\image-20230227150712327.png)

#### 提取p标签中的数据

![image-20230227150841323](.\images\image-20230227150841323.png)

#### 提取学号

![image-20230227151224361](.\images\image-20230227151224361.png)

#### 提取年月日

![image-20230227151459076](.\images\image-20230227151459076.png)

\ --->转义

![image-20230227152741193](.\images\image-20230227152741193.png)

#### 提取文件后缀

![image-20230227151650342](.\images\image-20230227151650342.png)

#### 提取所有电话号码

![image-20230227153548052](.\images\image-20230227153548052.png)

#### 非捕获分组

​	这个时候就可以使用非捕获组`(?:表达式)`，从而**不捕获数据**，还能使用分组的功能。跟不写?:效果差不多

![image](.\images\4.png)

#### 分组的回溯引用

​	可以使用**分组的回溯引用**，使用`\N`可以引用编号为`N`的分组，因此上述例子的代码我们可以改为：

![image](.\images\5.png)

通过这个例子，可以发现 `\1` 表示的就是第一个分组，在这里第一个分组匹配的是 `font` 所以`\1` 就代表`font`。

![image-20230227154611645](.\images\image-20230227154611645.png)



### 断言

![image-20230227203427313](.\images\image-20230227203427313.png)

**正向先行断言：**`(?=表达式)`，指在某个位置向后看，表示所在位置右侧必须能匹配`表达式`

**正向后行断言：**`(?<=表达式)`，指在某个位置向前看，表示所在位置左侧必须能匹配`表达式`

反向先行断言：**`(?!表达式)`，指在某个位置向后看，表示所在位置右侧不能匹配`表达式`

**反向后行断言：**`(?<!表达式)`，指在某个位置向前看，表示所在位置左侧不能匹配`表达式`

`(?=.*?[a-z])(?=.*?[A-Z]).+` 这段正则表达式规定了匹配的字符串中必须包含**至少一个大写和小写的字母**

#### 正向先行断言

![image-20230227203904713](.\images\image-20230227203904713.png)

#### 反向先行断言

![image-20230227204442384](.\images\image-20230227204442384.png)

#### 匹配标签

![image-20230227205230282](.\images\image-20230227205230282.png)

#### 正向后行断言

![image-20230227210032459](.\images\image-20230227210032459.png)

![image-20230227210810140](.\images\image-20230227210810140.png)

#### 反向后行断言

![image-20230227210302677](.\images\image-20230227210302677.png)

### 提取所有人生日

![image-20230227211232578](.\images\image-20230227211232578.png)

### 匹配所有小数

![image-20230227211759474](.\images\image-20230227211759474.png)

### 匹配所有XML标签

![image-20230227212110044](.\images\image-20230227212110044.png)



## 实战

```
网站检测:https://regexr-cn.com/

or

python脚本
def test(filepath):
    with open(filepath, "r") as file:
        code = file.read()
    file.close()
    code = re.sub(r'验证的正则表达式', "", code)
    print(code)
    
if __name__ == "__main__":
    test("./test.txt")
```



### 1.匹配行级注释//和块级注释/**/

```
网页版写法:(?<!:)\/\/.*|\/\*(\s|.)*?\*\/

python里面的写法:  
	code = re.sub(r'(?<!:)\/\/.*|\/\*(\s|.)*?\*\/', "", code)
     或者 '(?<!:)\\/\\/.*|\\/\\*(\\s|.)*?\\*\\/' 不加r


(?<!:)这个断言作用是防止网址http://xxx.com也匹配进去
```

### 2.匹配函数名

```
parrern=re.compile(r'\b([_A-Za-z]\w*)\b(?=\s*\()')

(?=\s*\()正向先行断言
后面(前可以出现任意空白字符
即 int test1                ()  test1这种可以匹配
```

### 3.匹配变量名

```
1.parrern = re.compile(r'\b([_A-Za-z]\w*)\b(?!\s*\w+)(?!\s*\()')

2.parrern = re.compile(r'\b([_A-Za-z]\w*)\b(?:(?=\s*\w+\()|(?!\s*\w+))(?!\s*\()')

(?!\s*\()  不匹配函数名
?: 非捕获分组
(?!\s*\w+)  前面不能是空白字符  如 int a; int不行,a可以
(?=\s*\w+\()) 这个后面括号前有一个字符--->感觉没啥用 ,用1就行,不行再用2试试


```

### 4.匹配字符串多行\连接情况

![image-20230301105502170](.\images\image-20230301105502170.png)

### 5.匹配非ASCII码

```
parrern = re.compile(r'[^\x00-\x7f]+')
```

### 6.文件重命名

```
^(.*\.)rar$  匹配以.rar结尾的文件
```

### 7.简单密码验证

```
我们的密码必须满足四个条件：

1.密码必须包含六到十个单词的字符
2.它必须至少包含一个小写字符
3.必须至少包含三个大写字符
4. 它必须至少包含一个数字


1.对于条件一:
^\w{6,10}$ 或者\A\w{6,10}\Z  在python中\A匹配字符串的开头等价于^ \Z匹配字符串的结尾等价于$

转化为正向先行断言
\A(?=\w{6,10}\Z)--->表示从字符串开头往后看到结尾有六到十个单词的字符

2.对于条件二:
.*?[a-z]-->至少有一个小写字符
==>将.*?换掉改为[^a-z]*[a-z]
 
转化为正向先行断言
(?=[^a-z]*[a-z])
 
合并条件一:
\A(?=\w{6,10}\z)(?=[^a-z]*[a-z])
 
3.对于条件三:
(?=(?:[^A-Z]*[A-Z]){3}
 
?:--->不捕获数据,这里不写其实也行
 
合并:
 \A(?=\w{6,10}\z)(?=[^a-z]*[a-z])(?=(?:[^A-Z]*[A-Z]){3})
 
 4.对于条件四:
  \D*\d --->至少包含一个数字
  
  \A(?=\w{6,10}\z)(?=[^a-z]*[a-z])(?=(?:[^A-Z]*[A-Z]){3})(?=\D*\d)
  
  最后把条件一换出来即可:
  \A(?=[^a-z]*[a-z])(?=(?:[^A-Z]*[A-Z]){3})(?=\D*\d)\w{6,10}\Z
```

### 8.匹配以#start#开头 #END#结尾中间的字符串

```
(?<=#START#).*?(?=#END#)
```

### 9.匹配小写字母后紧跟大写字母的位置

```
(?<=[a-z])(?=[A-Z]).+?




如果不加.+?就是零宽度匹配
s="AbcAdeAfg"
print(re.sub(r"(?<=[a-z])(?=[A-Z])"," ",s))  -->sub第二个参数也可以是函数
结果如下:
Abc Ade Afg
可用regex模板匹配零宽度匹配,re模板不行
print(regex.search(r"(?V1)(?<=[a-z])(?=[A-Z])","AbcAdeAfg"))
```

![image-20230311100023012](.\images\image-20230311100023012.png)

### 10.匹配以0开头且有两个不同数字的10位数号码

```
(?=0*[1-9])0\d{9}
```

![image-20230312161756186](.\images\image-20230312161756186.png)

### 11.匹配用数字分隔的单词

```
(?<!\D)[a-zA-Z]+(?!\D)
```

![image-20230312165232570](.\images\image-20230312165232570.png)

### 12.匹配数字后只跟一个下划线的数字

```
\d+(?=_(?!_))--->后面只跟一个下划线
(?<=(?<!_)_)\d+--->前面只跟一个下划线
```

![image-20230312165940112](.\images\image-20230312165940112.png)

![image-20230312170149177](C:\Users\zyj20\AppData\Roaming\Typora\typora-user-images\image-20230312170149177.png)

### 13.regex模块

```
零宽度匹配
可用regex模板匹配零宽度匹配,re模板不行
print(regex.search(r"(?V1)(?<=[a-z])(?=[A-Z])","AbcAdeAfg"))
递归匹配
print(regex.search(r"\w{3}\d{3}(?R)?","aaa111bbb222ccc333"))
<regex.Match object; span=(0, 18), match='aaa111bbb222ccc333'>
匹配最长回文串
print(regex.search(r"(\w+)(?:(?R)|\w?)\1","abaaabaa"))--->用处不大,长度越长越慢,指数级别增长
字符集差集
print(regex.search(r"(?V1)[a-z--[aeiou]]+","bcd tpl")) 
or
print(regex.search(r"(?V1)[a-z&&[^aeiou]]+","bcd tpl"))
<regex.Match object; span=(0, 3), match='bcd'>

||表示联合(“x||y”表示“x或y”)
~~(双波浪号)表示对称差分(“x~~y”表示“x或y，但不是两者”)
&&表示交集(“x&&y”表示“x和y”)
——(双破折号)表示差异(“x--y”表示“属于x但有不是y”)
```

